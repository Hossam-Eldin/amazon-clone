const net = require('net');
const tls = require('tls');
const events = require('events');
const util = require('util');

const flags = require('./flags.js');
const auth_plugins = require('./auth_plugins.js');
const packets = require('./packets.js');
const parser = require('./packet_parser.js').initialize(flags);
const sender = require('./packet_sender.js').initialize(flags);
const mysql_commands = require('./mysql_commands.js');

var packet_creator = new packets.Creator();

function PreparedStatement(stmt_id, params, columns, connection, completedCommand, queueCommand)
{
	this.id = stmt_id;
	this.params = params;

	Object.defineProperty(this, "id", {writable: false});
	Object.defineProperty(this, "params", {writable: false});

	var closed = false;

	this.sendLongData = function(parameter_id, data, error)
	{
		if (closed || connection.state != "connected")
			return; //TODO error
		//TODO convert the data to the appropriate format
		queueCommand(mysql_commands.STMT_SEND_LONG_DATA(packet_creator, stmt_id, parameter_id, data), void(0), error);
	};
	this.execute = function(parameters, response, error)
	{
		if (closed || connection.state != "connected")
			return; //TODO error
		if (parameters.length != params.length)
		{
			//TODO error
			return;
		}

		queueCommand(mysql_commands.STMT_EXECUTE(packet_creator, stmt_id, 0, true, params, parameters), createStmtExecuteHandler(connection, completedCommand, response, error), error);
	};
	this.close = function(error)
	{
		if (closed || connection.state != "connected")
			return; //TODO error
		closed = true;
		queueCommand(mysql_commands.STMT_CLOSE(packet_creator, stmt_id), void(0), error);
	};
	this.reset = function(response, error)
	{
		if (closed || connection.state != "connected")
			return; //TODO error

		queueCommand(mysql_commands.STMT_RESET(packet_creator, stmt_id), createStmtResetHandler(connection, completedCommand, response, error), error);
	};
}

function MySQLConnection()
{
	var self = this;
	var user = void(0);
	var packet_meta = {
		sequence_id: 0
	};
	var connection = {
		state: "new",
		socket: new net.Socket(),
		decoder: new packets.Decoder(packet_meta),
		protocol_version: 0x00,
		server_version: void(0),
		connection_id: 0,
		packets: packet_meta,
		max_packet_size: 65536,
		character_set: 8,
		capabilities: {
			CLIENT_LONG_PASSWORD: false,					//Use the improved version of Old Password Authentication. (Assumed to be set since 4.1.1)
			CLIENT_FOUND_ROWS: false,						//Send found rows instead of affected rows in EOF_Packet.
			CLIENT_LONG_FLAG: true,							//Server: Supports longer flags in Protocol::ColumnDefinition320.
															//Client: Expects longer flags in Protocol::ColumnDefinition320.
			CLIENT_CONNECT_WITH_DB: true,					//Server: Supports database-name in Handshake Response Packet.
															//Client: Handshake Response Packet contains a database-name.
			CLIENT_NO_SCHEMA: false,						//Server: Do not permit database.table.column.
			CLIENT_COMPRESS: false,							//Server: Supports the Compression protocol.
															//Client: Will use the compression protocol. (must instantly change to Compression protocol after successful authentication))
			CLIENT_ODBC: false,								//Special handling of ODBC behavior. (No special behavior since 3.22.)
			CLIENT_LOCAL_FILES: true,						//Can use LOAD DATA LOCAL (server: Enables the LOCAL INFILE request of LOAD DATA|XML., client: Will handle LOCAL INFILE request.)
			CLIENT_IGNORE_SPACE: true,						//Server: Parser can ignore spaces before '('.
															//Client: Let the parser ignore spaces before '('.
			CLIENT_PROTOCOL_41: true,						//Server: Supports the 4.1 protocol.
															//Client: Uses the 4.1 protocol.
			CLIENT_INTERACTIVE: false,						//Server: Supports interactive and noninteractive clients.
															//Client: Client is interactive.
			CLIENT_SSL: false,								//Server: Supports SSL.
															//Client: Switch to SSL after sending the capability-flags.
			CLIENT_IGNORE_SIGPIPE: false,					//Client: Do not issue SIGPIPE if network failures occur (libmysqlclient only).
			CLIENT_TRANSACTIONS: false,						//Server: Can send status flags in EOF_Packet.
															//Client: Expects status flags in EOF_Packet. (This flag is optional in 3.23, but always set by the server since 4.0.)
			CLIENT_RESERVED: false,
			CLIENT_SECURE_CONNECTION: true,					//Server: Supports Authentication::Native41.
															//Client: Supports Authentication::Native41.
			CLIENT_MULTI_STATEMENTS: true,					//Server: Can handle multiple statements per COM_QUERY and COM_STMT_PREPARE.
															//Client: May send multiple statements per COM_QUERY and COM_STMT_PREPARE. (Requires CLIENT_PROTOCOL_41)
			CLIENT_MULTI_RESULTS: true,						//Server: Can send multiple resultsets for COM_QUERY.
															//Client: Can handle multiple resultsets for COM_QUERY. (Requires CLIENT_PROTOCOL_41)
			CLIENT_PS_MULTI_RESULTS: false,					//Server: Can send multiple resultsets for COM_STMT_EXECUTE.
															//Client: Can handle multiple resultsets for COM_STMT_EXECUTE. (Requires CLIENT_PROTOCOL_41)
			CLIENT_PLUGIN_AUTH: true, //true/false?			//Server: Sends extra data in Initial Handshake Packet and supports the pluggable authentication protocol.
															//Client: Supports authentication plugins. (Requires CLIENT_PROTOCOL_41)
			CLIENT_CONNECT_ATTRS: false,					//Server: Permits connection attributes in Protocol::HandshakeResponse41.
															//Client: Sends connection attributes in Protocol::HandshakeResponse41.
			CLIENT_PLUGIN_AUTH_LENENC_CLIENT_DATA: true,	//Server: Understands length-encoded integer for auth response data in Protocol::HandshakeResponse41.
															//Client: Length of auth response data in Protocol::HandshakeResponse41 is a length-encoded integer.
			CLIENT_CAN_HANDLE_EXPIRED_PASSWORDS: false,		//Server: Announces support for expired password extension.
															//Client: Can handle expired passwords.
			CLIENT_SESSION_TRACK: true,						//Server: Can set SERVER_SESSION_STATE_CHANGED in the Status Flags and send session-state change data after a OK packet.
															//Client: Expects the server to send sesson-state changes after a OK packet.
			CLIENT_DEPRECATE_EOF: true						//Server: Can send OK after a Text Resultset.
															//Client: Expects an OK (instead of EOF) after the resultset rows of a Text Resultset.
			//To support CLIENT_SESSION_TRACK, additional information must be sent after all successful commands. Although the OK packet is extensible, the EOF packet is not due to the overlap of its bytes with the content of the Text Resultset Row.
			//Therefore, the EOF packet in the Text Resultset is replaced with an OK packet. EOF packets are deprecated as of MySQL 5.7.5.
		}
	};

	var command_queue = [];

	var queueCommand = function(data, handler, error)
	{
		command_queue.push({data: data, handler: handler, error: error});

		if (command_queue.length == 1)
			executeCommand();
	};

	var executeCommand = function()
	{
		if (connection != null)
		{
			if (connection.state == "connected")
			{
				connection.decoder.onpacket = command_queue[0].handler;
				connection.socket.write(packets.toByteBuffer(command_queue[0].data, connection));
				if (command_queue[0].handler == void(0))
					completedCommand();
			} //else error?
		}
	};

	var completedCommand = function()
	{
		command_queue.splice(0, 1);
		connection.packets.sequence_id = 0;
		if (command_queue.length > 0)
			executeCommand();
		else
			connection.decoder.onpacket = noHandler;
	};

	this.connect = function(options, login)
	{
		if (typeof login != 'object')
			throw new TypeError("Must provide login information!");

		if (typeof login.password != 'string')
			login.password = void(0);
		if (typeof login.database != 'string')
			login.database = void(0);

		this.connect = void(0);

		user = login;
		connection.state = "connecting";
		var handshakeHandler = createHandshakeHandler(login, connection, function(res)
		{
			connection.packets.sequence_id = 0;
			connection.decoder.onpacket = noHandler;
			connection.state = "connected";

			if (res.type == "ERR")
			{
				connection.socket.destroy();
				self.emit('error', {type: 'loginerr', data: res});
			} else
				self.emit('connect', res);

			if (res.type == "OK")
			{
				if (typeof login.database == 'string' && !connection.capabilities.CLIENT_CONNECT_WITH_DB)
				{
					command_queue.splice(0, 0, {data: mysql_commands.INIT_DB(packet_creator, database), handler: createOKERRHandler(connection, completedCommand, response, error), error: error});
				}
				if (command_queue.length > 0)
					executeCommand();
			}
		}, function(err)
		{
			connection.socket.destroy();
			self.emit('error', {type: "connectionerr", data: err});
		});

		connection.socket.on('connect', function()
		{
			connection.decoder.onpacket = handshakeHandler;
		});
		connection.socket.on('data', function(buffer)
		{
			connection.decoder.feed(buffer);
		});
		connection.socket.on('timeout', function()
		{
			self.emit('timeout');
		});
		connection.socket.on('error', function(error)
		{
			self.emit('error', {type: "socketerr", data: error}); //Types: socketerr, loginerr, connectionerr
		});
		connection.socket.on('close', function(had_error)
		{
			connection.decoder.destroy();
			connection.decoder = void(0);
			user = void(0);
			packet_meta = void(0);
			connection = void(0);
			queueCommand = void(0);
			executeCommand = void(0);
			completedCommand = void(0);

			for (var i = 0; i < command_queue.length; i++)
				command_queue[i].error({type: "connection_closed"});
			command_queue = void(0);

			self.emit('close',  had_error);
		});
		connection.socket.connect(options);
	};

	this.setTimeout = function(timeout)
	{
		if (typeof timeout != 'number' || number < 0)
			throw new TypeError("Timeout must be a non-negative number!");
		if (connection == void(0))
			throw new Error("Can't setTimeout to a closed MySQL connection!");

		connection.socket.setTimeout(info.timeout);
	};

	this.ref = function()
	{
		if (connection == void(0))
			throw new Error("Can't ref a closed MySQL connection!");

		connection.socket.ref();
	};

	this.unref = function()
	{
		if (connection == void(0))
			throw new Error("Can't unref a closed MySQL connection!");

		connection.socket.unref();
	};

	this.close = function()
	{
		if (connection == void(0) || connection.state == "new")
			return; //TODO error
		else
		{
			if (connection.state == "connecting")
			{
				connection.socket.destroy();
			} else if (connection.state == "closing")
			{
				connection.socket.destroy();
			} else
			{
				var rip = function(idc)
				{
					if (connection != void(0))
						connection.socket.destroy();
				};
				//TODO remove all functions
				queueCommand(mysql_commands.QUIT(packet_creator), createOKERRHandler(connection, completedCommand, rip, rip), rip, rip);
				connection.state = "closing";
			}
		}
	};

	var createStmt = function(id, params, columns)
	{
		return new PreparedStatement(id, params, columns, connection, completedCommand, queueCommand);
	};

	//error types:
	// * malformed_data: packet didn't have enough data or had too much data
	// * unexpected_data: received unknown data, server is probably sending gibberish
	// * unknown_auth_plugin: server requested an unknown auth plugin
	// * unsupported_version: client doesn't support server version

	//responses:
	// * result(response, columns[, rows]): the entire result of a query has been received, if no row handler exists, then all rows will be passed as the last argument
	// Optional:
	// * row(row, columns): a row has been received
	// * end(): all queries have been executed
	// * TODO local_infile(): local_infile request handler
	this.query = function(query, response, error) //response: {row, result, end, local_infile}
	{
		if ((typeof response != 'function' && typeof response != 'object') || typeof error != 'function')
			return; //TODO error
		if (typeof response == 'object' && (typeof response.result != 'function'/* || typeof response.error != 'function'*/))
			return; //TODO error
		if (connection == void(0) || connection.state == 'new')
			return; //TODO error
		
		queueCommand(mysql_commands.QUERY(packet_creator, query), createQueryHandler(connection, completedCommand, response, error), error);
	};
	
	this.prepare = function(query, response, error)
	{
		//TODO check
		queueCommand(mysql_commands.STMT_PREPARE(packet_creator, query), createStmtPrepareHandler(connection, completedCommand, response, error, createStmt), error);
	};

	this.setDatabase = function(database, response, error)
	{
		//TODO check
		queueCommand(mysql_commands.INIT_DB(packet_creator, database), createOKERRHandler(connection, completedCommand, response, error), error);
	};
}

util.inherits(MySQLConnection, events.EventEmitter);

function createHandshakeHandler(info, connection, response, error)
{
	var handshakeBegin = function()
	{
		try
		{
			var data = parser.readHandshakePacket(connection.decoder);
			
			if (typeof data != 'object')
			{
				connection.decoder.onpacket = noHandler;
				error({type: "unexpected_data", raw: data}); //TODO
				return;
			}

			connection.protocol_version = data.protocol_version;
			connection.server_version = data.server_version;
			connection.connection_id = data.connection_id;
			connection.character_set = data.character_set;
			
			flags.combineCapabilities(connection.capabilities, data.capabilities);
			
			connection.capabilities.CLIENT_CONNECT_WITH_DB &= typeof info.database == 'string';
	
			var auth = auth_plugins[data.auth_plugin.name];
			
			var auth_plugin = {
				name: auth.name,
				data: void(0)
			};
			
			if (typeof auth == 'undefined')
				auth = auth_plugins.mysql_native_password;
			
			if (typeof info.password == 'string')
				auth_plugin.data = auth.response(info.password, data.auth_plugin.data);
			else
				auth_plugin.data = auth.no_password(data.auth_plugin.data);
			
			var response_data = sender.createHandshakeResponse(packet_creator, info, connection, auth_plugin);
			if (typeof response_data == 'object')
			{
				connection.decoder.onpacket = handshakeResponse;
				connection.socket.write(packets.toByteBuffer(response_data, connection));
			} else
			{
				connection.decoder.onpacket = noHandler;
				error({type: "unsupported_version"}); //TODO
				return;
			}
		} catch (e)
		{
			if (e instanceof packets.SuperSecretError)
				error({type: "malformed_data", error: e.realError});
			else
				throw e;
		}
	};
	
	var handshakeResponse = function()
	{
		try
		{
			if (parser.isOKPacket(connection))
			{
				response(parser.readOKPacket(connection));
			} else if (parser.isERRPacket(connection))
			{
				response(parser.readERRPacket(connection));
			} else if (connection.decoder.peek() == 0xFE)
			{
				//TODO handle this!
				connection.decoder.get();
				
				var plugin_name;
				var auth_data = [];
				
				if (connection.decoder.packet_length == 0)
				{
					plugin_name = "mysql_old_password";
					//TODO Switch to Old Password Authentication
					console.log("Switching to Old Password Authentication");
					error({type: "unknown_auth_plugin"});
				} else
				{
					var plugin_name = connection.decoder.getString();
					var auth_data = connection.decoder.getBytesBuffer(connection.decoder.packet_length);
					console.log("Switching to " + plugin_name, auth_data);
					//TODO Switch to this authentication plugin
				}
				//(simply reply with the authentication data (string[eof]) or close connection)
				//Will respond with Protocol::AuthMoreData or OK_Packet or ERR_Packet
				error({type: "unknown_auth_plugin"}); //TODO
			} else
			{
				error({type: "unexpected_data", raw: connection.decoder.getBytesBuffer(connection.decoder.packet_length)}); //TODO
			}
		} catch (e)
		{
			if (e instanceof packets.SuperSecretError)
				error({type: "malformed_data", error: e.realError});
			else
				throw e;
		}
	};
	
	return handshakeBegin;
}

function createQueryHandler(connection, completedCommand, response, error)
{
	var clean = function()
	{
		readQueryResponse = void(0);
		handleColumnDefinitions = void(0);
		handleEOF = void(0);
		handleRows = void(0);
		errored = void(0);
		finished = void(0);
		clean = void(0);
		connection.decoder.onpacket = noHandler;
	};

	var finished = function()
	{
		clean();
		if (typeof response.end == 'function')
			response.end();
		completedCommand();
	};

	var errored = function(err)
	{
		clean();
		error(err);
		completedCommand();
	}

	var column_count;
	var columns_parsed;
	var columns;
	var rows;

	var result = response;
	if (typeof result.result == 'function')
		result = result.result;

	var readQueryResponse = function()
	{
		try
		{
			var type = connection.decoder.peek();

			if (parser.isOKPacket(connection))
			{
				var ok = parser.readOKPacket(connection);
				var hasMoreResults = ok.status.SERVER_MORE_RESULTS_EXISTS;
				result(ok, [], []);

				if (hasMoreResults)
					;//wait for more
				else
					finished();

			} else if (parser.isERRPacket(connection))
			{
				result(parser.readERRPacket(connection), [], []);
				finished();
			} else if (connection.decoder.peek() == 0xFB)
			{
				//TODO Handle LOCAL_INFILE response
			} else
			{
				column_count = connection.decoder.getIntV();
				columns_parsed = 0;

				columns = new Array(column_count);

				connection.decoder.onpacket = handleColumnDefinitions;
			}
		} catch (e)
		{
			clean();
			completedCommand();
			if (e instanceof packets.SuperSecretError)
				error({type: "malformed_data", error: e.realError});
			else
				throw e;
		}
	};

	var handleColumnDefinitions = function()
	{
		try
		{
			columns[columns_parsed] = parser.readColumnDefinition(connection, false);

			columns_parsed++;

			if (columns_parsed == column_count)
			{
				rows = [];
				if (connection.capabilities.CLIENT_DEPRECATE_EOF)
					connection.decoder.onpacket = handleRows;
				else
					connection.decoder.onpacket = handleEOF;
			}
		} catch (e)
		{
			clean();
			completedCommand();
			if (e instanceof packets.SuperSecretError)
				error({type: "malformed_data", error: e.realError});
			else
				throw e;
		}
	};

	var handleEOF = function()
	{
		try
		{
			connection.decoder.onpacket = handleRows;
			if (parser.isEOFPacket(connection))
				parser.readEOFPacket(connection);
			else
				handleRows();
		} catch (e)
		{
			clean();
			completedCommand();
			if (e instanceof packets.SuperSecretError)
				error({type: "malformed_data", error: e.realError});
			else
				throw e;
		}
	};

	var handleRows = function()
	{
		try
		{
			if (parser.isOKPacket(connection))
			{
				var ok = parser.readOKPacket(connection);
				var hasMoreResults = ok.status.SERVER_MORE_RESULTS_EXISTS;
				result(ok, columns, rows);

				if (hasMoreResults)
					connection.decoder.onpacket = readQueryResponse;
				else
					finished();

			} else if (parser.isEOFPacket(connection))
			{
				var eof = parser.readEOFPacket(connection);
				var hasMoreResults = eof.status.SERVER_MORE_RESULTS_EXISTS;
				result(eof, columns, rows);
				if (hasMoreResults)
					connection.decoder.onpacket = readQueryResponse;
				else
					finished();
			} else if (parser.isERRPacket(connection))
			{
				result(parser.readERRPacket(connection), [], []);
				finished();
			} else
			{
				var row = parser.readTextResultsetRow(connection, columns);
				if (typeof response.row == 'function')
					response.row(row, columns);
				else
					rows.push(row)
			}
		} catch (e)
		{
			clean();
			completedCommand();
			if (e instanceof packets.SuperSecretError)
				error({type: "malformed_data", error: e.realError});
			else
				throw e;
		}
	};

	return readQueryResponse;
}

function createStmtPrepareHandler(connection, completedCommand, response, error, createStmt)
{
	var stmt_prepare_ok;
	var params;
	var columns;

	var param_amt = 0;
	var column_amt = 0;

	var clean = function()
	{
		clean = void(0);
		errored = void(0);
		finished = void(0);
		readStmtPrepareOK = void(0);
		readParamDefinition = void(0);
		readColumnDefinition = void(0);
		connection.decoder.onpacket = noHandler;
	};

	var errored = function(err)
	{
		clean();
		error(err);
		completedCommand();
	};

	var finished = function()
	{
		clean();
		response({type: "OK", warning_count: stmt_prepare_ok.warning_count, stmt: createStmt(stmt_prepare_ok.id, params, columns)});
		completedCommand();
	};

	var readStmtPrepareOK = function()
	{
		try
		{
			if (parser.isERRPacket(connection))
			{
				clean();
				response(parser.readERRPacket(connection));
				completedCommand();
			} else if (connection.decoder.peek() == 0x00)
			{
				stmt_prepare_ok = parser.readPrepareOKPacket(connection);

				params = new Array(stmt_prepare_ok.num_params);
				columns = new Array(stmt_prepare_ok.num_columns);

				if (stmt_prepare_ok.num_params > 0)
					connection.decoder.onpacket = readParamDefinition;
				else if (stmt_prepare_ok.num_columns > 0)
					connection.decoder.onpacket = readColumnDefinition;
				else
					finished();
			} else
			{
				errored({type: "unexpected_data", raw: connection.decoder.getBytesBuffer(connection.decoder.packet_length)}); //TODO
			}
		} catch (e)
		{
			clean();
			completedCommand();
			if (e instanceof packets.SuperSecretError)
				error({type: "malformed_data", error: e.realError});
			else
				throw e;
		}
	};

	var readParamDefinition = function()
	{
		try
		{
			params[param_amt] = parser.readColumnDefinition(connection, false);
			param_amt++;

			if (param_amt == stmt_prepare_ok.num_params)
			{
				if (stmt_prepare_ok.num_columns > 0)
					connection.decoder.onpacket = readColumnDefinition;
				else
					finished();
			}
		} catch (e)
		{
			clean();
			completedCommand();
			if (e instanceof packets.SuperSecretError)
				error({type: "malformed_data", error: e.realError});
			else
				throw e;
		}
	};

	var readColumnDefinition = function()
	{
		try
		{
			columns[column_amt] = parser.readColumnDefinition(connection, false);
			column_amt++;

			if (column_amt == stmt_prepare_ok.num_columns)
				finished();
		} catch (e)
		{
			clean();
			completedCommand();
			if (e instanceof packets.SuperSecretError)
				error({type: "malformed_data", error: e.realError});
			else
				throw e;
		}
	}

	return readStmtPrepareOK;
}

function createStmtExecuteHandler(connection, completedCommand, response, error)
{
	var clean = function()
	{
		readQueryResponse = void(0);
		handleColumnDefinitions = void(0);
		handleEOF = void(0);
		handleRows = void(0);
		errored = void(0);
		finished = void(0);
		clean = void(0);
		connection.decoder.onpacket = noHandler;
	};

	var finished = function()
	{
		clean();
		if (typeof response.end == 'function')
			response.end();
		completedCommand();
	};

	var errored = function(err)
	{
		clean();
		error(err);
		completedCommand();
	}

	var column_count;
	var columns_parsed;
	var columns;
	var rows;

	var result = response;

	if (typeof result.result == 'function')
		result = result.result;

	var readExecuteResponse = function()
	{
		try
		{
			var type = connection.decoder.peek();

			if (parser.isOKPacket(connection))
			{
				var ok = parser.readOKPacket(connection);
				var hasMoreResults = ok.status.SERVER_MORE_RESULTS_EXISTS;
				result(ok, [], []);

				if (hasMoreResults)
					;//wait for more
				else
					finished();
			} else if (parser.isERRPacket(connection))
			{
				result(parser.readERRPacket(connection), [], []);
				finished();
			} else if (connection.decoder.peek() == 0xFB)
			{
				//TODO LOCAL_INFILE (mysql doesn't support LOCAL_INFILE for prepared statements yet, but might eventually)
			} else
			{
				column_count = connection.decoder.getIntV();
				columns_parsed = 0;

				columns = new Array(column_count);

				connection.decoder.onpacket = handleColumnDefinitions;
			}
		} catch (e)
		{
			clean();
			completedCommand();
			if (e instanceof packets.SuperSecretError)
				error({type: "malformed_data", error: e.realError});
			else
				throw e;
		}
	};

	var handleColumnDefinitions = function()
	{
		try
		{
			columns[columns_parsed] = parser.readColumnDefinition(connection, false);

			columns_parsed++;

			if (columns_parsed == column_count)
			{
				rows = [];
				if (connection.capabilities.CLIENT_DEPRECATE_EOF)
					connection.decoder.onpacket = handleRows;
				else
					connection.decoder.onpacket = handleEOF;
			}
		} catch (e)
		{
			clean();
			completedCommand();
			if (e instanceof packets.SuperSecretError)
				error({type: "malformed_data", error: e.realError});
			else
				throw e;
		}
	};

	var handleEOF = function()
	{
		try
		{
			connection.decoder.onpacket = handleRows;
			if (parser.isEOFPacket(connection))
				parser.readEOFPacket(connection);
			else
				handleRows();
		} catch (e)
		{
			clean();
			completedCommand();
			if (e instanceof packets.SuperSecretError)
				error({type: "malformed_data", error: e.realError});
			else
				throw e;
		}
	};

	var handleRows = function()
	{
		try
		{
			if (connection.decoder.peek() == 0xFE)
			{
				var ok = parser.readOKPacket(connection);
				var hasMoreResults = ok.status.SERVER_MORE_RESULTS_EXISTS;
				result(ok, columns, rows);
				if (hasMoreResults)
					connection.decoder.onpacket = readExecuteResponse;
				else
					finished();
			} else if (parser.isERRPacket(connection))
			{
				result(parser.readERRPacket(connection), [], []);
				finished();
			} else
			{
				var row = parser.readBinaryResultsetRow(connection, columns);
				if (typeof response.row == 'function')
					response.row(row, columns);
				else
					rows.push(row)
			}
		} catch (e)
		{
			clean();
			completedCommand();
			if (e instanceof packets.SuperSecretError)
				error({type: "malformed_data", error: e.realError});
			else
				throw e;
		}
	};

	return readExecuteResponse;
}

function createStmtResetHandler(connection, completedCommand, response, error)
{
	return function()
	{
		try
		{
			if (parser.isOKPacket(connection))
				response(parser.readOKPacket(connection));
			else if (parser.isERRPacket(connection))
				response(parser.readERRPacket(connection));
			else
				error({type: "unexpected_data"});
			completedCommand();
		} catch (e)
		{
			completedCommand();
			if (e instanceof packets.SuperSecretError)
				error({type: "malformed_data", error: e.realError});
			else
				throw e;
		}
	};
}

function createOKERRHandler(connection, completedCommand, response, error)
{
	return function()
	{
		try
		{
			if (parser.isOKPacket(connection))
				response(parser.readOKPacket(connection));
			else if (parser.isERRPacket(connection))
				response(parser.readERRPacket(connection));
			else
				error({type: "unexpected_data"});
			completedCommand();
		} catch (e)
		{
			completedCommand();
			if (e instanceof packets.SuperSecretError)
				error({type: "malformed_data", error: e.realError});
			else
				throw e;
		}
	};
}

function noHandler()
{
}

//To respond to an LOCAL_INFILE request, send one or multiple packets containing only raw data, then send an empty packet

module.exports = {
	Connection: MySQLConnection
	//Client: MySQLClient
};

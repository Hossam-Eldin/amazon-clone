var MYSQL_TYPE_DECIMAL = 0x00;
var MYSQL_TYPE_TINY = 0x01;
var MYSQL_TYPE_SHORT = 0x02;
var MYSQL_TYPE_LONG = 0x03;
var MYSQL_TYPE_FLOAT = 0x04;
var MYSQL_TYPE_DOUBLE = 0x05;
var MYSQL_TYPE_NULL = 0x06;
var MYSQL_TYPE_TIMESTAMP = 0x07;
var MYSQL_TYPE_LONGLONG = 0x08;
var MYSQL_TYPE_INT24 = 0x09;
var MYSQL_TYPE_DATE = 0x0a;
var MYSQL_TYPE_TIME = 0x0b;
var MYSQL_TYPE_DATETIME = 0x0c;
var MYSQL_TYPE_YEAR = 0x0d;
var MYSQL_TYPE_NEWDATE = 0x0e;
var MYSQL_TYPE_VARCHAR = 0x0f;
var MYSQL_TYPE_BIT = 0x10;
var MYSQL_TYPE_TIMESTAMP2 = 0x11;
var MYSQL_TYPE_DATETIME2 = 0x12;
var MYSQL_TYPE_TIME2 = 0x13;
var MYSQL_TYPE_NEWDECIMAL = 0xf6;
var MYSQL_TYPE_ENUM = 0xf7;
var MYSQL_TYPE_SET = 0xf8;
var MYSQL_TYPE_TINY_BLOB = 0xf9;
var MYSQL_TYPE_MEDIUM_BLOB = 0xfa;
var MYSQL_TYPE_LONG_BLOB = 0xfb;
var MYSQL_TYPE_BLOB = 0xfc;
var MYSQL_TYPE_VAR_STRING = 0xfd;
var MYSQL_TYPE_STRING = 0xfe;
var MYSQL_TYPE_GEOMETRY = 0xff;

var floatView = new DataView(new ArrayBuffer(8));

/* * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                    Packet parser                    *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * */

var PacketDecoder = function PacketDecoder(sid)
{
	this.onpacket = void(0);
	
	this.data = void(0);
	this.position = 0;
	this.length = 0;
	this.lb = void(0);
	
	this.packet_length = 0;
	this.sequence_id = -1;
	
	this.sid = sid;
	
	this.handlingPacket = false;
};

PacketDecoder.prototype.incrementPosition = function(amt)
{
	if (typeof amt != 'number')
		amt = 1;
	
	this.position += amt;
	this.length -= amt;
	this.packet_length -= amt;
	
	while (this.position > 0 && this.position >= this.data.buffer.length)
	{
		this.position -= this.data.buffer.length;
		if (this.data.nb == void(0))
			this.lb = void(0);
		this.data = this.data.nb;
	}
};

PacketDecoder.prototype.feed = function(buffer)
{
	var object = {nb: void(0), buffer: buffer};
	this.length += buffer.length;
	
	if (this.data == void(0))
		this.data = object;
	else
		this.lb.nb = object;
	this.lb = object;
	
	while (true)
	{
		if (this.sequence_id == -1 && this.length > 4)
		{
			this.packet_length = this.getInt(3) + 1;
			this.sequence_id = this.get();
			if (this.sequence_id != this.sid.sequence_id)
			{
				console.warn("Bad sequence_id: " + this.sequence_id + " (expecting " + this.sid.sequence_id + ")"); //TODO better logging
			}
			this.sid.sequence_id = this.sequence_id + 1;
		} else if (this.sequence_id != -1 && this.length >= this.packet_length)
		{
			this.handlingPacket = true;
			this.onpacket();
			if (this.packet_length > 0)
			{
				console.log("Remaining packet length: " + this.packet_length);
				console.log("Raw: ", this.getBytesBuffer(this.packet_length));
				throw new SuperSecretError(new RangeError("Too much data in packet!"));
			}
			this.sequence_id = -1;
			this.handlingPacket = false;
		} else
		{
			break;
		}
	}
};

PacketDecoder.prototype.peek = function()
{
	if (this.handlingPacket && this.packet_length == 0)
		throw new SuperSecretError(new RangeError("No more data in packet!"));
	return this.data.buffer[this.position];
};

PacketDecoder.prototype.get = function()
{
	if (this.handlingPacket && this.packet_length == 0)
		throw new SuperSecretError(new RangeError("No more data in packet!"));
	var res = this.data.buffer[this.position];
	this.incrementPosition(1);
	return res;
};

PacketDecoder.prototype.skip = function(amt)
{
	if ((typeof amt != 'number' || !Number.isInteger(amt) || amt < 0) && typeof amt != 'undefined')
		throw new TypeError("Argument must be a positive integer or zero!");

	if (this.handlingPacket && this.packet_length - amt < 0)
		throw new SuperSecretError(new RangeError("No more data in packet!"));

	if (typeof amt == 'undefined')
		this.incrementPosition(1);
	else
		this.incrementPosition(amt);

	return this;
};

PacketDecoder.prototype.getInt = function(size)
{
	if (typeof size != 'number')
		return this.get();
	if (size > 4)
		throw new RangeError("Parsing integers larger than 4 bytes currently not supported!"); //TODO FIX THIS!!!
	
	var res = 0;
	
	for (var i = 0; i < size; i++)
		res |= this.get() << (i * 8);

	if (res < 0)
		res += 0xFFFFFFFF + 1;
	
	return res;
};

PacketDecoder.prototype.getIntV = function()
{
	var type = this.get();
	
	if (type == 0xFC)
		return this.getInt(2);
	else if (type == 0xFD)
		return this.getInt(3);
	else if (type == 0xFE)
		return this.getInt(8); //TODO Javascript numbers only support 52 bits of precision, not 64!!!!
	else
		return type;
};

PacketDecoder.prototype.getType = function(type)
{
	switch (type.type_id)
	{
		case MYSQL_TYPE_STRING:
		case MYSQL_TYPE_VARCHAR:
		case MYSQL_TYPE_VAR_STRING:
		case MYSQL_TYPE_ENUM:
		case MYSQL_TYPE_SET:
		case MYSQL_TYPE_NEWDECIMAL:
			return this.getString(this.getIntV());
			break;

		case MYSQL_TYPE_LONG_BLOB:
		case MYSQL_TYPE_MEDIUM_BLOB:
		case MYSQL_TYPE_BLOB:
		case MYSQL_TYPE_TINY_BLOB:
		case MYSQL_TYPE_GEOMETRY:
		case MYSQL_TYPE_DECIMAL:
			return this.getBytesBuffer(this.getIntV()); //TODO is this correct? String can mean byte[] according to MySQL docs
			break;

		case MYSQL_TYPE_BIT: //ceil(length / 8) bits //TODO test this!
			var data = this.getBytesBuffer(this.getIntV());
			var res = new Array(type.column_length);
			for (var i = 0; i < type.column_length; i++)
				res[type.column_length - i - 1] = ((data[Math.ceil(type.column_length / 8) - 1 - Math.floor(i / 8)] >>> (i % 8)) & 1) == 1;

			return res;
			break;

		case MYSQL_TYPE_LONGLONG: //TODO further test this code!!!
			var lb = this.getInt(4);
			var hb = this.getInt(4);

			var negative = false;
			var chars = [];

			if (!type.flags.UNSIGNED && ((hb >>> 31) & 1) == 1) //If this LONGLONG is signed and the sign bit is set
			{
				negative = true;

				lb = ~lb; //Flip all bits
				hb = ~hb;

				lb += 1;
				if (lb == 0) //If the subtraction overflew
					hb += 1;

				if (lb < 0)
					lb += 0xFFFFFFFF + 1;
				if (hb < 0)
					hb += 0xFFFFFFFF + 1;
			}

			while (hb > 0 || lb > 0)
			{
				var remlow = lb % 10;
				var remhigh = hb % 10;

				chars.push("" + ((remlow + remhigh * 6) % 10)); //Append the remainder when dividing entire long long by 10 to the string. Since hb represents the amount of 4294967296s, it adds 6s to the remainder.

				lb -= remlow; //Remove all the 1/10s that would exist after dividing by 10
				hb -= remhigh; //Remove all the 429496729 + 6/10s that would exist after dividing by 10, since hb represents the amount of 4294967296s

				lb /= 10;
				hb /= 10;

				lb += 429496729 * remhigh; //Add all the removed 429496729s to lb

				remlow += 6 * remhigh; //Add the removed 1/10s together
				remlow -= remlow % 10;
				lb += remlow / 10;

				//Overflow can't happen, because:
				//max(low) = 2^32/base - 1/base
				//max(high) = 2^32 - 2^32/base
				//max(low + high) = 2^32 - 1 + (base - 1)/base
				//Always lower than 2^32, because the remainder gets discarded.
			}

			chars = chars.reverse().join("");

			if (chars.length == 0)
				chars = "0";
			else if (negative)
				chars = "-" + chars;

			return chars;
			break;

		case MYSQL_TYPE_LONG:
		case MYSQL_TYPE_INT24:
			var i = this.getInt(4);
			if (!type.flags.UNSIGNED)
			{
				if (((i >>> 31) & 1) == 1)
				{
					i -= 0xFFFFFFFF + 1;
				}
			}
			return i;
			break;

		case MYSQL_TYPE_SHORT:
		case MYSQL_TYPE_YEAR:
			var i = this.getInt(2);
			if (!type.flags.UNSIGNED)
			{
				if (((i >>> 15) & 1) == 1)
				{
					i -= 1 << 16;
				}
			}
			return i;
			break;

		case MYSQL_TYPE_TINY:
			var i = this.get();
			if (!type.flags.UNSIGNED)
			{
				if (((i >>> 7) & 1) == 1)
				{
					i -= 1 << 8;
				}
			}
			return i;
			break;

		case MYSQL_TYPE_DOUBLE:
			floatView.setUint32(0, this.getInt(4));
			floatView.setUint32(4, this.getInt(4));
			return floatView.getFloat64(0, true);
			break;

		case MYSQL_TYPE_FLOAT:
			floatView.setUint32(0, this.getInt(4));
			return floatView.getFloat32(0, true);
			break;

		case MYSQL_TYPE_DATE:
		case MYSQL_TYPE_DATETIME:
		case MYSQL_TYPE_TIMESTAMP:
			var len = this.get();
			if (len == 0)
			{
				return {
					year: 0,
					month: 0,
					day: 0,
					hour: 0,
					minute: 0,
					second: 0,
					micro_second: 0
				};
			} else if (len == 4)
			{
				return {
					year: this.getInt(2),
					month: this.get(),
					day: this.get(),
					hour: 0,
					minute: 0,
					second: 0,
					micro_second: 0
				};
			} else if (len == 7)
			{
				return {
					year: this.getInt(2),
					month: this.get(),
					day: this.get(),
					hour: this.get(),
					minute: this.get(),
					second: this.get(),
					micro_second: 0
				};
			} else if (len == 11)
			{
				return {
					year: this.getInt(2),
					month: this.get(),
					day: this.get(),
					hour: this.get(),
					minute: this.get(),
					second: this.get(),
					micro_second: this.getInt(4)
				};
			} else
			{
				//TODO error!
			}
			break;

		case MYSQL_TYPE_TIME:
			var len = this.get();
			if (len == 0)
			{
				return {
					negative: false,
					days: 0,
					hours: 0,
					minutes: 0,
					seconds: 0,
					micro_seconds: 0
				};
			} else if (len == 8)
			{
				return {
					negative: this.get() == 1,
					days: this.getInt(4),
					hours: this.get(),
					minutes: this.get(),
					seconds: this.get(),
					micro_seconds: 0
				};
			} else if (len == 12)
			{
				return {
					negative: this.get() == 1,
					days: this.getInt(4),
					hours: this.get(),
					minutes: this.get(),
					seconds: this.get(),
					micro_seconds: this.getInt(4)
				};
			} else
			{
				//TODO error!
			}
			break;
	}

	return;
};

PacketDecoder.prototype.getBytesBuffers = function(length)
{
	if (typeof length != 'number' || !Number.isInteger(length) || length < 0)
		throw new TypeError("Argument must be a positive integer or zero!");
	
	if (this.handlingPacket && this.packet_length - length < 0)
		throw new SuperSecretError(new RangeError("No more data in packet!"));
	
	var result = [];
	
	while (length > 0)
	{
		var take = Math.min(length, this.data.buffer.length - this.position);
		
		result.push(this.data.buffer.slice(this.position, this.position + take));
		
		this.incrementPosition(take);
		length -= take;
	}
	
	return result;
};

PacketDecoder.prototype.getBytesBuffer = function(length)
{
	if (typeof length != 'number' || !Number.isInteger(length) || length < 0)
		throw new TypeError("Argument must be a positive integer or zero!");
	
	return Buffer.concat(this.getBytesBuffers(length), length);
};

PacketDecoder.prototype.getString = function(length)
{
	if (typeof length != 'undefined')
	{
		if (typeof length != 'number' || !Number.isInteger(length) || length < 0)
			throw new TypeError("Argument must be a positive integer or zero!");
		if (this.handlingPacket && this.packet_length - length < 0)
			throw new SuperSecretError(new RangeError("No more data in packet!"));

		return this.getBytesBuffer(length).toString("ascii");
	} else
	{
		var result = [];
		var result_size = 0;
		
		while (true)
		{
			var buf = this.data.buffer;
			
			for (var i = this.position; i < buf.length; i++)
			{
				if (buf[i] == 0x00)
				{
					result.push(buf.slice(this.position, i));
					result_size += i - this.position;
					this.incrementPosition(i - this.position + 1);
					
					return Buffer.concat(result, result_size).toString("ascii");
				}
			}
			
			result.push(buf.slice(this.position));
			result_size += buf.length - this.position;
			this.incrementPosition(buf.length - this.position);
		}
	}
};

PacketDecoder.prototype.getStringV = function()
{
	var len = this.getIntV();
	return this.getString(len);
};

PacketDecoder.prototype.destroy = function()
{
	this.onpacket = void(0);
	this.data = void(0);
	this.lb = void(0);
	this.sid = void(0);
};

/* * * * * * * * * * * * * * * * * * * * * * * * * * * *
 *                   Packet creator                    *
 * * * * * * * * * * * * * * * * * * * * * * * * * * * */

var PacketCreator = function PacketCreator()
{
	this.data = [];
	this.length = 0;
};

PacketCreator.prototype.put = function(num)
{
	if (typeof num == 'number')
	{
		if (num < 0)
			num += 256;
		this.data.push(num);
		this.length++;
	} else if (num instanceof Buffer || num instanceof Array)
	{
		this.data.push(num);
		this.length += num.length;
	}
	
	return this;
};

PacketCreator.prototype.putInt = function(num, size)
{
	if (num < 0)
		num += 1 << (size * 8);
	var a = new Array(size);
	for (var i = 0; i < size; i++)
		a[i] = ((num >> (i * 8)) & 0xFF);
	
	this.data.push(a);
	
	this.length += a.length;
	
	return this;
};

PacketCreator.prototype.putIntV = function(num)
{
	if (num < 0xFB)
		return this.put(num);
	else if (num < (1 << 16))
		return this.put(0xFC).putInt(num, 2);
	else if (num < (1 << 24))
		return this.put(0xFD).putInt(num, 3);
	else
		return this.put(0xFE).putInt(num, 8);
};

PacketCreator.prototype.putType = function(value, type)
{
	switch (type.type_id) //TODO completely rewrite this!
	{
		case MYSQL_TYPE_STRING:
		case MYSQL_TYPE_VARCHAR:
		case MYSQL_TYPE_VAR_STRING:
		case MYSQL_TYPE_ENUM:
		case MYSQL_TYPE_SET:
		case MYSQL_TYPE_LONG_BLOB:
		case MYSQL_TYPE_MEDIUM_BLOB:
		case MYSQL_TYPE_BLOB:
		case MYSQL_TYPE_TINY_BLOB:
		case MYSQL_TYPE_GEOMETRY:
		case MYSQL_TYPE_BIT:
		case MYSQL_TYPE_DECIMAL:
		case MYSQL_TYPE_NEWDECIMAL: //TODO is this correct? String can mean byte[] according to MySQL docs
			if (typeof value == 'number')
				value = "" + value;
			this.putIntV(value.length);
			if (typeof value == 'string')
				this.putString(value);
			else
				this.put(value);
			break;

		case MYSQL_TYPE_LONGLONG:
			//TODO handle long long (javascript numbers are Float64, with only 52 bits of precision)
			this.putInt(value.array[0], 4);
			this.putInt(value.array[1], 4);
			break;

		case MYSQL_TYPE_LONG:
		case MYSQL_TYPE_INT24:
			this.putInt(value, 4);
			break;

		case MYSQL_TYPE_SHORT:
		case MYSQL_TYPE_YEAR:
			this.putInt(value, 2);
			break;

		case MYSQL_TYPE_TINY:
			this.put(value);
			break;

		case MYSQL_TYPE_DOUBLE:
			floatView.setFloat64(0, value, true);
			var o = new Array(8);
			for (var i = 0; i < this.length; i++)
				o[i] = floatView.getUint8(i);
			this.put(o);
			break;

		case MYSQL_TYPE_FLOAT:
			floatView.setFloat32(0, value, true);
			this.put(floatView.getUint32(0, true));
			break;

		case MYSQL_TYPE_DATE:
		case MYSQL_TYPE_DATETIME:
		case MYSQL_TYPE_TIMESTAMP:
			if (value.micro_second == 0) //TODO make this code less redundant
			{
				if (value.second == 0 && value.minute == 0 && value.hour == 0)
				{
					if (value.day == 0 && value.month == 0 && value.year == 0)
					{
						this.put(0);
					} else
					{
						this.put(4);
						this.putInt(value.year, 2);
						this.put(value.month);
						this.put(value.day);
					}
				} else
				{
					this.put(7);
					this.putInt(value.year, 2);
					this.put(value.month);
					this.put(value.day);
					this.put(value.hour);
					this.put(value.minute);
					this.put(value.second);
				}
			} else
			{
				this.put(11);
				this.putInt(value.year, 2);
				this.put(value.month);
				this.put(value.day);
				this.put(value.hour);
				this.put(value.minute);
				this.put(value.second);
				this.putInt(value.micro_second, 4);
			}
			break;

		case MYSQL_TYPE_TIME: //TODO make this code less redundant
			if (value.micro_seconds == 0)
			{
				if (value.seconds == 0 && value.minutes == 0 && value.hours == 0 && value.days == 0 && value.negative == false)
				{
					this.put(0);
				} else
				{
					this.put(8);
					this.put(value.negative ? 1 : 0);
					this.putInt(value.days, 4);
					this.put(value.hours);
					this.put(value.minutes);
					this.put(value.seconds);
				}
			} else
			{
				this.put(12);
				this.put(value.negative ? 1 : 0);
				this.putInt(value.days, 4);
				this.put(value.hours);
				this.put(value.minutes);
				this.put(value.seconds);
				this.putInt(value.micro_seconds, 4);
			}
			break;
	}

	return;
};

PacketCreator.prototype.putString = function(string, encoding)
{
	return this.putBytes(Buffer.from(string, encoding));
};

PacketCreator.prototype.putStringN = function(string, encoding)
{
	return this.putBytes(Buffer.from(string, encoding)).put(0);
};

PacketCreator.prototype.putBytes = function(data)
{
	this.data.push(data);
	
	this.length += data.length;
	
	return this;
};

PacketCreator.prototype.pop = function()
{
	var creator = {data: this.data, length: this.length};
	
	this.data = [];
	this.length = 0;
	
	return creator;
};

function toByteBuffer(creator, connection)
{
	var buf = Buffer.alloc(creator.length + 4);
	
	buf[0] = creator.length & 0xFF;
	buf[1] = (creator.length >> 8) & 0xFF;
	buf[2] = (creator.length >> 16) & 0xFF;
	buf[3] = connection.packets.sequence_id;
	
	connection.packets.sequence_id += 1;
	
	var position = 4;
	
	for (var i = 0; i < creator.data.length; i++)
	{
		var obj = creator.data[i];
		if (obj instanceof Buffer)
		{
			position += obj.copy(buf, position);
		} else if (obj instanceof Array)
		{
			for (var j = 0; j < obj.length; j++)
			{
				buf[position] = obj[j];
				position++;
			}
		} else if (typeof obj == 'number')
		{
			buf[position] = obj & 0xFF;
			position++;
		}
	}
	
	return buf;
}

function SuperSecretError(realError)
{
	this.superSecretSauce = "Malformed packet";
	this.realError = realError;
}

module.exports = {
	Creator: PacketCreator,
	Decoder: PacketDecoder,
	toByteBuffer: toByteBuffer,
	SuperSecretError: SuperSecretError
};

function SLEEP(packet) //Internal server function
{
	return packet.put(0x00).pop();
	//ERR
}

function QUIT(packet) //Tell server to stop this connection
{
	return packet.put(0x01).pop();
	//OK or connection closed
}

function INIT_DB(packet, database) //Change active database
{
	return packet.put(0x02).putString(database).pop();
	//OK or ERR
}

function QUERY(packet, query)
{
	return packet.put(0x03).putString(query).pop();
	//OK or ERR or Resultset or INFILE_REQUEST
}

function FIELD_LIST(packet, table, field_wildcard) //Lists fields in a table (Deprecated, should use QUERY)
{
	return packet.put(0x04).putStringN(table).putString(field_wildcard).pop();
	//columns[columns_parsed] = readColumnDefinition(connection, TRUE);
	//ERR or [n * ColumnDefinition, EOF]
}

function CREATE_DB(packet, database) //Creates a database (Deprecated, should use QUERY)
{
	return packet.put(0x05).putString(database).pop();
	//OK or ERR
}

function DROP_DB(packet, database) //Deletes a database (Deprecated, should use QUERY)
{
	return packet.put(0x06).putString(database).pop();
	//OK or ERR
}

var REFRESH_GRANT = 0x01;
var REFRESH_LOG = 0x02;
var REFRESH_TABLES = 0x04;
var REFRESH_HOSTS = 0x08;
var REFRESH_STATUS = 0x10;
var REFRESH_THREADS = 0x20;
var REFRESH_SLAVE = 0x40;
var REFRESH_MASTER = 0x80;

function REFRESH(packet, what) //Flushes/resets internal systems (Deprecated, should use QUERY)
{
	return packet.put(0x07).put(what).pop();
	//OK or ERR
}

var SHUTDOWN_DEFAULT = 0x00;
var SHUTDOWN_WAIT_CONNECTIONS = 0x01;
var SHUTDOWN_WAIT_TRANSACTIONS = 0x02;
var SHUTDOWN_WAIT_UPDATES = 0x08;
var SHUTDOWN_WAIT_ALL_BUFFERS = 0x10;
var SHUTDOWN_WAIT_CRITICAL_BUFFERS = 0x11;
var KILL_QUERY = 0xfe;
var KILL_CONNECTION = 0xff;

function SHUTDOWN(packet, command) //Shuts down the server (Deprecated, should use QUERY)
{
	packet.put(0x08);
	if (typeof command == 'number')
		packet.put(command);
	return packet.pop();
	//EOF or ERR
}

function STATISTICS(packet)
{
	return packet.put(0x09).pop();
	//String.EOF
}

function PROCESS_INFO(packet)
{
	return packet.put(0x0a).pop();
	//Text::Resultset or ERR
}

function CONNECT(packet)
{
	return packet.put(0x0b).pop();
	//ERR
}

function PROCESS_KILL(packet, connection_id) //Kill a connection with id (Deprecated, should use QUERY)
{
	return packet.put(0x0c).putInt(connection_id, 4).pop();
	//OK or ERR
}

function DEBUG(packet)
{
	return packet.put(0x0d).pop();
	//EOF or ERR
}

function PING(packet)
{
	return packet.put(0x0e).pop();
	//OK
}

function TIME(packet)
{
	return packet.put(0x0f).pop();
	//ERR
}

function DELAYED_INSERT(packet)
{
	return packet.put(0x10).pop();
	//ERR
}

/*CHANGE_USER: function(user, auth_response, database, character_set, auth_name, attributes)
{
	connection.decoder.put(0x11);
	connection.decoder.putStringN(user);
	if (connection.capabilities.CLIENT_SECURE_CONNECTION)
	{
		connection.decoder.put(auth_response.length);
		connection.decoder.put(auth_response);
	} else
	{
		connection.decoder.putStringN(auth_response);
	}
	connection.decoder.putStringN(database);
	
	if (character_set != void(0))
	{
		connection.decoder.putInt(character_set, 2);
		
		if (connection.capabilities.CLIENT_PLUGIN_AUTH)
		{
			connection.decoder.putStringN(auth_name);
		}
		
		if (connection.capabilities.CLIENT_CONNECT_ATTRS)
		{
			if (typeof attributes != 'array')
				attributes = [];
			
			//TODO place attributes!
			//for ()
		}
	}
	//Authentication Method Switch Request Packet or ERR
},
BINLOG_DUMP: function() //TODO
{
	connection.decoder.put(0x12);
	//Binlog network stream or EOF (if BINLOG_DUMP_NON_BLOCK is set) or ERR
},*/

function TABLE_DUMP(packet, database, table) //Dump a table
{
	return packet.put(0x13).put(database.length).putString(database).put(table.length).putString(table).pop();
	//Table dump or ERR
}

function CONNECT_OUT(packet)
{
	return packet.put(0x14).pop();
	//ERR
}

function REGISTER_SLAVE(packet, server_id, slave_hostname, slave_user, slave_password, slave_port, replication_rank, master_id) //Register a slave
{
	packet.put(0x15).putInt(server_id, 4).put(slave_hostname.length).putString(slave_hostname).put(slave_user.length).putString(slave_user);
	return packet.put(slave_password.length).putString(slave_password).putInt(slave_port, 2).putInt(replication_rank, 4).putInt(master_id, 4).pop();
	//OK or ERR
}

function STMT_PREPARE(packet, query)
{
	return packet.put(0x16).putString(query).pop();
	//COM_STMT_PREPARE_OK or ERR
}

var CURSOR_TYPE_NO_CURSOR = 0x00;
var CURSOR_TYPE_READ_ONLY = 0x01;
var CURSOR_TYPE_FOR_UPDATE = 0x02;
var CURSOR_TYPE_SCROLLABLE = 0x04;

function STMT_EXECUTE(packet, stmt_id, cursor_flags/*, iteration_count, */, resend_types, types, params)
{
	packet.put(0x17).putInt(stmt_id, 4).put(cursor_flags).putInt(/*iteration_count*/1, 4);

	if (params.length > 0)
	{
		var num = 0;

		for (var i = 0; i < params.length; i++)
			if (params[i] == void(0))
				num |= 1 << i;

		packet.putInt(num, Math.floor((params.length + 7) / 8));

		if (resend_types)
			packet.put(1);
		else
			packet.put(0);

		if (resend_types)
		{
			for (var i = 0; i < types.length; i++)
			{
				packet.put(types[i].type_id).put(types[i].flags_raw);
			}
		}

		for (var i = 0; i < params.length; i++)
		{
			if (params[i] != void(0))
				packet.putType(params[i], types[i]);
		}
	}

	return packet.pop();
	//OK or ERR or Binary::Resultset
}

function STMT_SEND_LONG_DATA(packet, stmt_id, param_id, data) //Sends or appends (if used repeatedly) data to a parameter
{
	return packet.put(0x18).putInt(stmt_id, 4).putInt(param_id, 2).put(data).pop();
	//No response
}

function STMT_CLOSE(packet, stmt_id) //Deallocates a prepared statement
{
	return packet.put(0x19).putInt(stmt_id, 4).pop();
	//No response
}

function STMT_RESET(packet, stmt_id) //Resets the data of a prepared statement that was accumulated with COM_STMT_SEND_LONG_DATA and closes the cursor if it was opened with COM_STMT_EXECUTE
{
	return packet.put(0x1a).putInt(stmt_id, 4).pop();
	//OK or ERR
}

var MYSQL_OPTION_MULTI_STATEMENTS_ON = 0;
var MYSQL_OPTION_MULTI_STATEMENTS_OFF = 1;

function SET_OPTION(packet, option)
{
	return packet.put(0x1b).putInt(option, 2).pop();
	//EOF or ERR
}

function STMT_FETCH(packet, stmt_id, num_rows) //Fetch rows from an existing resultset after a COM_STMT_EXECUTE with a non-zero cursor flag
{
	return packet.put(0x1c).putInt(stmt_id, 4).putInt(num_rows, 4).pop();
	//multi-resultset or ERR
}

function DAEMON(packet)
{
	return packet.put(0x1d).pop();
	//ERR
}


/*function BINLOG_DUMP_GTID(packet) //TODO //request the Binlog Network Stream based on a GTID
{
	return packet.put(0x1e).pop();
	//Binlog Network Stream or ERR or EOF (if BINLOG_DUMP_NON_BLOCK is set)
}*/

function RESET_CONNECTION(packet)
{
	return packet.put(0x1f).pop();
	//OK or ERR
}

module.exports = {
	SLEEP: SLEEP,
	QUIT: QUIT,
	INIT_DB: INIT_DB,
	QUERY: QUERY,
	FIELD_LIST: FIELD_LIST,
	CREATE_DB: CREATE_DB,
	DROP_DB: DROP_DB,
	REFRESH: REFRESH,
	SHUTDOWN: SHUTDOWN,
	STATISTICS: STATISTICS,
	PROCESS_INFO: PROCESS_INFO,
	CONNECT: CONNECT,
	PROCESS_KILL, PROCESS_KILL,
	DEBUG: DEBUG,
	PING: PING,
	TIME: TIME,
	DELAYED_INSERT: DELAYED_INSERT,
	//CHANGE_USER: CHANGE_USER,
	//BINLOG_DUMP, BINLOG_DUMP,
	TABLE_DUMP: TABLE_DUMP,
	CONNECT_OUT: CONNECT_OUT,
	REGISTER_SLAVE: REGISTER_SLAVE,
	STMT_PREPARE: STMT_PREPARE,
	STMT_EXECUTE: STMT_EXECUTE,
	STMT_SEND_LONG_DATA: STMT_SEND_LONG_DATA,
	STMT_CLOSE: STMT_CLOSE,
	STMT_RESET: STMT_RESET,
	SET_OPTION: SET_OPTION,
	STMT_FETCH: STMT_FETCH,
	DAEMON: DAEMON,
	//BINLOG_DUMP_GTID: BINLOG_DUMP_GTID,
	RESET_CONNECTION: RESET_CONNECTION
};